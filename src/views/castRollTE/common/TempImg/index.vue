<template>
  <div class="part-box" :style="{ height: showGraph ? '850px' : '200px' }">
    <div class="part-title">铸轧温度图像</div>
    <div class="echarts-item" v-if="showGraph">
      <div class="px-10 pt-4 pb-12">
        <v-btn-toggle v-model="type" divided variant="outlined">
          <v-btn value="head-distance" @click="calcChart">
            <span class="hidden-sm-and-down">头部-距离-温度</span>
          </v-btn>

          <v-btn value="head-time" @click="calcChart">
            <span class="hidden-sm-and-down">头部-时间-温度</span>
          </v-btn>

          <template v-if="route.path == '/directCastRoll'">
            <v-btn value="tail-distance" @click="calcChart">
              <span class="hidden-sm-and-down">尾部-距离-温度</span>
            </v-btn>

            <v-btn value="tail-time" @click="calcChart">
              <span class="hidden-sm-and-down">尾部-时间-温度</span>
            </v-btn>
          </template>
        </v-btn-toggle>
      </div>
      <div id="graph1" class="echarts"></div>
    </div>
    <div v-else class="no-data">提交后生成图像</div>
  </div>
</template>

<script setup>
import * as echarts from "echarts";
import { reactive } from "vue";
import { useRoute } from "vue-router";
// import calcResultMock from "@/assets/mock/calcResult.json";

const route = useRoute();

// onMounted(() => {
//   renderChart();
// });

// 折线图配置
const option = {
  title: {
    text: "",
  },
  tooltip: {
    trigger: "axis",
  },
  toolbox: {
    show: true,
    feature: {
      saveAsImage: {},
    },
  },
  legend: {
    data: [
      { name: "平均温度", itemStyle: { opacity: 0 } },
      { name: "心部温度", itemStyle: { opacity: 0 } },
      { name: "表面温度", itemStyle: { opacity: 0 } },
    ],
  },
  grid: {
    left: "5%",
    right: "8%",
    bottom: "8%",
    containLabel: true,
  },
  xAxis: {
    type: "value",
    name: "距离(m)",
    nameTextStyle: {
      fontSize: 16, // 设置字体大小
      padding: [0, 0, 0, 15], // 上右下左与原位置距离
    },
  },
  yAxis: {
    type: "value",
    name: "轧线温度场(℃)",
    nameTextStyle: {
      fontSize: 16, // 设置字体大小
      padding: [0, 0, 25, 20], // 上右下左与原位置距离
    },
  },
  series: [
    {
      name: "平均温度",
      type: "line",
      showSymbol: false,
      itemStyle: {
        normal: {
          color: "#6ce56e",
        },
      },
      data: [],
    },
    {
      name: "心部温度",
      type: "line",
      showSymbol: false,
      itemStyle: {
        normal: {
          color: "#EE6666",
          lineStyle: {
            type: "dashed",
          },
        },
      },
      data: [],
    },
    {
      name: "表面温度",
      type: "line",
      showSymbol: false,
      itemStyle: {
        normal: {
          color: "#5c7bd9",
          lineStyle: {
            type: "dashed",
          },
        },
      },
      data: [],
    },
  ],
};

const showGraph = ref(false);
const type = ref("head-distance");

// 表头数据
let billetData = reactive({});
// 图表渲染数据
let chartData = reactive([]);

//外部调用方法
const renderChart = (calcResult) => {
  showGraph.value = true;
  // const { data } = calcResultMock; // mock数据
  const { data } = calcResult; // 真实数据
  const { billetParams, calculateData } = data;
  billetData = billetParams;
  chartData = calculateData;
  calcChart();
};

// 计算并重新渲染图表
const calcChart = () => {
  let index;
  let xAxisType;

  switch (type.value) {
    case "head-distance":
      index = 0;
      xAxisType = "distance";
      break;
    case "head-time":
      index = 0;
      xAxisType = "time";
      break;
    case "tail-distance":
      index = 1;
      xAxisType = "distance";
      break;
    case "tail-time":
      index = 1;
      xAxisType = "time";
      break;
  }

  // 隔离option
  const copyOption = JSON.parse(JSON.stringify(option));

  // 平均温度
  copyOption.series[0].data = chartData[index].map((item) => {
    const xAxisValue = item[xAxisType];
    const yAxisValue = item.averageTemp;
    return [xAxisValue, yAxisValue];
  });

  // 心部温度
  copyOption.series[1].data = chartData[index].map((item) => {
    const xAxisValue = item[xAxisType];
    const yAxisValue = item.coreTemp;
    return [xAxisValue, yAxisValue];
  });

  // 表面温度
  copyOption.series[2].data = chartData[index].map((item) => {
    const xAxisValue = item[xAxisType];
    const yAxisValue = item.surfaceTemp;
    return [xAxisValue, yAxisValue];
  });

  // x轴单位
  if (xAxisType == "distance") {
    copyOption.xAxis.name = "距离(m)";
  } else {
    copyOption.xAxis.name = "时间(s)";
  }

  // 如果是方坯/矩形坯计算
  if (billetData.billetShape == "方坯" || billetData.billetShape == "矩形坯") {
    copyOption.legend.data.pop(); // 删除最后一个元素
    copyOption.legend.data.push(
      { name: "角部温度", itemStyle: { opacity: 0 } },
      { name: "铸坯高度方向表面温度", itemStyle: { opacity: 0 } },
      { name: "铸坯宽度方向表面温度", itemStyle: { opacity: 0 } }
    );
    copyOption.series.pop();
    copyOption.series.push(
      {
        name: "角部温度",
        type: "line",
        showSymbol: false,
        itemStyle: {
          normal: {
            color: "#5c7bd9",
            lineStyle: {
              type: "dashed",
            },
          },
        },
        data: [],
      },
      {
        name: "铸坯高度方向表面温度",
        type: "line",
        showSymbol: false,
        itemStyle: {
          normal: {
            color: "#fac858",
            lineStyle: {
              type: "dashed",
            },
          },
        },
        data: [],
      },
      {
        name: "铸坯宽度方向表面温度",
        type: "line",
        showSymbol: false,
        itemStyle: {
          normal: {
            color: "#fc8452",
            lineStyle: {
              type: "dashed",
            },
          },
        },
        data: [],
      }
    );

    // 角部温度
    copyOption.series[2].data = chartData[index].map((item) => {
      const xAxisValue = item[xAxisType];
      const yAxisValue = item.cornerTemp;
      return [xAxisValue, yAxisValue];
    });

    // 铸坯高度方向表面温度
    copyOption.series[3].data = chartData[index].map((item) => {
      const xAxisValue = item[xAxisType];
      const yAxisValue = item.heightSurfaceTemp;
      return [xAxisValue, yAxisValue];
    });

    // 铸坯宽度方向表面温度
    copyOption.series[4].data = chartData[index].map((item) => {
      const xAxisValue = item[xAxisType];
      const yAxisValue = item.widthSurfaceTemp;
      return [xAxisValue, yAxisValue];
    });
  }

  // 重新渲染图表
  initChart(copyOption);
};

// 初始化图表的函数
const initChart = (copyOption) => {
  // 等待DOM渲染完成后再初始化图表
  nextTick(() => {
    const chartDom = document.getElementById("graph1");
    // const myChart = echarts.init(chartDom); // 原生
    const myChart = echarts.init(chartDom, null, { devicePixelRatio: 2 }); // 2倍分辨率
    myChart.setOption(copyOption);
  });
};

defineExpose({
  renderChart,
});
</script>

<style lang="scss" scoped>
.part-box {
  background: #fff;

  .part-title {
    height: 50px;
    display: flex;
    align-items: center;
    background-color: #f7f9fa;
    font-size: 15px;
    padding: 20px;
    border-radius: 4px;
    margin-bottom: 30px;

    &::before {
      content: "";
      display: block;
      width: 2px;
      height: 20px;
      background-color: #0c5fff;
      margin-right: 10px;
    }
  }

  .echarts-item {
    width: 100%;
    border-radius: 8px;
    margin-top: -5px;

    .echarts {
      width: 100%;
      height: 680px;
    }
  }

  .no-data {
    text-align: center;
    color: #a6a6a6;
    margin-top: 65px;
  }
}
</style>
